# 09-Index Concurrency Control

目前为止讨论的所有数据结构都是**单线程**的。

但是**DBMS需要允许多个线程安全地访问数据结构**，以利用额外的CPU内核并隐藏磁盘I/O暂停。

并发控制协议是DBMS用于确保共享对象上并发操作的“正确”结果的方法。

## Latches Overview

**Latch锁**也称闩锁（轻量级锁），锁定的时间必须非常短，若持续时间长，则应用性能会非常差。在innoDb引擎中，latch又分为mutex（互斥量）和rwlock（读写锁）。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。

**Lock锁**的对象是事务，用来锁定数据库中的对象，比如：表、页、行，一般lock锁仅在事务commit或rollback后进行释放。（不同事务隔离界别的释放时间可能不同），lock存在死锁机制。

摘自知乎：https://zhuanlan.zhihu.com/p/508550634

**两者之间的区别**

![image-20230225212017246](Index-Concurrency-Control.assets/image-20230225212017246.png)

**Latch Mode**

读模式和写模式

- 读模式

- - 多个线程可以同时访问一个对象而不阻塞
  - 如果一个线程占据了读锁，另一个线程还可以继续申请读锁

- 写模式

- - 同一时刻只能有一个线程访问对象
  - 如果一个线程已经有写锁了，则另一个线程不能申请读锁，也不能申请写锁

**Latch的实现**

- 使用互斥原语，类似C++中std::mutex
- 使用读写锁🔒



## Hash Table Latching

哈希表加锁中，所有线程都以相同的方向移动，一次只能访问一个页面/插槽。

哈希表加锁按照粒度分为 page latches 和 slot latches 。

### page latches

将哈希表分段的切开，分段加锁，一个线程操作的时候就给这一段加锁。

![image-20230225212729639](Index-Concurrency-Control.assets/image-20230225212729639.png)

### slot latches

特点：按照槽加锁。

![image-20230225212909521](Index-Concurrency-Control.assets/image-20230225212909521.png)



【补充】原子操作 – 比较和交换

![image-20230225213029846](Index-Concurrency-Control.assets/image-20230225213029846.png)

让CPU判断要操作的数值是不是指定的数值，是的话进行操作。

## B+ Tree Latching

我们希望允许多个线程同时读取和更新B+树。

我们需要防止两类问题：

1. 试图同时修改节点内容的线程。

2. 一个线程遍历树，而另一个线程拆分/合并节点。

举例：

![image-20230225213318155](Index-Concurrency-Control.assets/image-20230225213318155.png)

例如，线程T1要删除44，T1会从根节点遍历，找到44将其删除。

这时，来了个线程T2，要找41.如下图所示。

![image-20230225213444894](Index-Concurrency-Control.assets/image-20230225213444894.png)

但是，线程T1删除完数值44时，会将树进行重构，导致线程T2找不到41。

### Latch Crabbing & Coupling

这节内容取自：[CMU 15445 学习笔记—8 Index Concurrency Control](https://mp.weixin.qq.com/s/QuJxaq2A7lukfJQhwTk2hQ)

B+ 树中将保证线程安全的加锁方式统一叫做 latch crabbing/coupling。

其基本思路是对需要访问的节点及其父节点都加锁，同时为了减少锁定父节点带来的开销，在确定父节点是“安全”的之后，可以将父节点的锁释放掉。

这里的父节点的“安全”指的是，在本次操作中，确定不会发生节点的分裂或合并，也就是说父节点的状态不会发生变更。

当在 B+ 树上 read 时，从根节点开始向下搜寻，首先对扫描到的节点加读锁，向下一层时，将父节点的锁直接释放，这里能直接释放的原因是整个操作是只读的，不会变更 B+ 树节点的状态。

当需要对 B+ 树更新（write/delete）时，同样从根节点进行搜寻，并且在经过的节点上加写锁，并进一步判断，如果当前节点是“安全”的，那么释放所有父级节点的锁。

### Better Latching Algorithm

之前B+树加锁都是从根节点开始加，这极大影响了性能。但这其实是悲观锁的概念，因为觉得可能会需要有大的改变。

因此，这小节算法使用乐观锁优化。

具体步骤：

在B+ 树UpDate数据的时候，搜索根节点到叶子节点的过程中加读锁，只在最后的叶子节点时再对其加写锁。并且判断，此操作会不会发生 split/merge 操作。

如果不会，那么操作成功完成，如果会的话，那么则会放弃这个操作，并且以悲观锁的方案从头执行操作，即对所有的节点加写锁。

##  Leaf Node Scans



目前为止，所有示例中的线程都以“自上而下”的方式获取了锁存器。

- 线程只能从低于其当前节点的节点获取锁存器。

- 如果所需的锁存器不可用，则线程必须等待，直到它变为可用。

但是如果线程想要从一个叶节点移动到另一个叶结点呢？

例子1：只读操作

首先是读操作，有两个线程都去读取数据，并且在各自扫描的叶子节点都加了读锁。

线程T1要扫描B，线程T2要扫描A。但由于加的是读锁。都可共享，因此不会产生死锁。



![image-20230225215713404](Index-Concurrency-Control.assets/image-20230225215713404.png)

例子2：读写操作

 T1 需要删除 4，T2 需要扫描数据，他们都各自枷锁。导致此时两个线程都无法获取到另一个 page 的锁，从而产生死锁。

![image-20230225215912230](Index-Concurrency-Control.assets/image-20230225215912230.png)

